/**
 * *****************************************************************************
 * Copyright (c) 2016-2018, KAIST.
 * All rights reserved.
 *
 * Use is subject to license terms.
 *
 * This distribution may include materials developed by third parties.
 * ****************************************************************************
 */

/*
 * A.5 Functions and Programs
 * Definition of JavaScript functions and programs
 */
module kr.ac.kaist.safe.parser.Declaration(Statement, Symbol, Identifier, Keyword, Spacing);

import Statement;
import Symbol;
import Identifier;
import Keyword;
import Spacing;
import Expression;

/*
 * Program ::= w Stmts? w EndOfFile
 */
public Program File =
     initParser a1:UseStrictDirectives? w a2:TopLevelStmts? closeParser
     { Span span = createSpan(yyStart,yyCount);
       ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
       scala.collection.immutable.List<Stmt> ses;
       if (a2 == null) ses = nilSes;
       else ses = toList(a2);
       HashMap<String, Span> map = new HashMap<String, Span>();
       if (a1 == null)
           yyValue = new Program(info, new TopLevel(info, nilFds, nilVds,
                                                    toList(list(new Stmts(info, ses, false)))));
       else
           yyValue = new Program(info, new TopLevel(info, nilFds, nilVds,
                                                    toList(list(new Stmts(info, ses, true)))));
     };
void initParser = w { initParser(); };
void closeParser = w EndOfFile
     { // revert to the original value for NodeUtil.keepComments
       NodeUtil.setKeepComments(keepComments);
       writer.close();
       fw.close();
     };

private String UseStrictDirectives =
     yyValue:UseStrictDirective UseStrictDirective+
     { // ECMAScript 5.1 Section 14.1
       excLog.signal(new NoMultipleUseStrict(createSpan(yyStart,yyCount)));
     }
   / yyValue:UseStrictDirective
   ;

private String UseStrictDirective =
     ["] yyValue:"use strict" ["] (w semicolon / w comma)?
   / ['] yyValue:"use strict" ['] (w semicolon / w comma)?
   ;

/*
 * Stmts ::= Stmt (w Stmt)*
 */
private List<Stmt> TopLevelStmts =
     a1:Stmt a2s:(w Stmt)*
     { // Disable recording comments for now for the end of file
       NodeUtil.setKeepComments(false);
       yyValue = cons(a1, a2s.list());
     };

/*
 * Stmts ::= Stmt (w Stmt)*
 */
private List<Stmt> Stmts =
     a1:Stmt a2s:(w Stmt)*
     { yyValue = cons(a1, a2s.list()); };

/*
 * Stmt ::=
 *   FunctionDeclaration
 * | Statement
 */
private Stmt Stmt =
     FunctionDeclaration
   / ClassDeclaration
   / Statement ;

/*
 *   class App {
 *      methodName() {  ...  }
 *   }
 *
 *   function App() {  ... constructor ... }            // FunctionDeclaration
 *   App.prototype.methodName = function() { ... }      // ExprStmt
 *
 *   ClassDeclaration = class w Id w (extends w LeftHandSide)? w { ClassBody }
 */

ClassDeclaration ClassDeclaration = class w className:Id (w extends w superClass:LeftHandSide)? w opencurly w ClassBody w closecurly {
    System.out.println("class name: " + className.toString());
    Span span = createSpan(yyStart,yyCount);

    yyValue = new ClassDeclaration(
        NodeUtil.makeASTNodeInfo(span),
        className
        //methods
    );
};

// Doesn't work.
public LHS ClassExpression = class (w Id)? (w extends w superClass:LeftHandSide)? w opencurly w ClassBody w closecurly {
    Span span = createSpan(yyStart,yyCount);
    yyValue = new Bool(NodeUtil.makeASTNodeInfo(span), true);
};

Stmt ClassBody = (w ClassElement)* {
    Span span = createSpan(yyStart,yyCount);
    yyValue = new EmptyStmt(NodeUtil.makeASTNodeInfo(span));
};

Stmt ClassElement = (MethodDefinition / static w MethodDefinition / semicolon) {
    Span span = createSpan(yyStart,yyCount);
    yyValue = new EmptyStmt(NodeUtil.makeASTNodeInfo(span));
};

Stmt MethodDefinition = PropName w openparen a2:(w Params)? w closeparen w a3:FunctionBody {
    Span span = createSpan(yyStart,yyCount);
    yyValue = new EmptyStmt(NodeUtil.makeASTNodeInfo(span));
}
/ <Getter> get w a1:PropName w openparen w closeparen w a2:FunctionBody {
    //Span span = createSpan(yyStart,yyCount);
    //ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
    //yyValue = new GetProp(info, a1,
    //                             new Functional(info, nilFds, nilVds,
    //                                            new Stmts(info, toList(a2._1()), a2._3()),
    //                                            a1.toId(), nilIds, a2._2(), false));
    Span span = createSpan(yyStart,yyCount);
    yyValue = new EmptyStmt(NodeUtil.makeASTNodeInfo(span));
}
/ <Setter> set w a1:PropName w openparen w a2:Id w closeparen w a3:FunctionBody {
    //Span span = createSpan(yyStart,yyCount);
    //ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
    //yyValue = new SetProp(info, a1,
    //                           new Functional(info, nilFds, nilVds,
    //                                          new Stmts(info, toList(a3._1()), a3._3()),
    //                                          a1.toId(), toList(list(a2)), a3._2(), false));
    Span span = createSpan(yyStart,yyCount);
    yyValue = new EmptyStmt(NodeUtil.makeASTNodeInfo(span));
};




/*
 * FunctionDeclaration ::= function w Id w ( (w Params)? w ) w FunctionBody
 */
FunDecl FunctionDeclaration =
     function w a1:Id w openparen a2:(w Params)? w closeparen w a3:FunctionBody
     { Span span = createSpan(yyStart,yyCount);
       ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
       scala.collection.immutable.List<Id> ids;
       if (a2 == null) ids = nilIds;
       else ids = toList(a2);
       yyValue = new FunDecl(info,
                             new Functional(info, nilFds, nilVds,
                                            new Stmts(info, toList(a3._1()), a3._3()),
                                            a1, ids, a3._2(), false), false);
     };

/*
 * Params ::= Id (w , w Id)*
 */
public List<Id> Params =
     a1:Id a2s:(w void:comma w Id)+
     { yyValue = cons(a1, a2s.list()); }
   / a1:Id
     { yyValue = list(a1); };

/*
 * FunctionBody ::= { w Stmt* w }
 */
public Tuple3<List<Stmt>, String, Boolean> FunctionBody =
     opencurly w a1:UseStrictDirectives? w closecurly
     { if (a1 == null)
         yyValue = new Tuple3<List<Stmt>, String, Boolean>(
                       nilJSes,
                       "{}",
                       Boolean.valueOf(false));
       else
         yyValue = new Tuple3<List<Stmt>, String, Boolean>(
                       nilJSes,
                       "{ 'use strict'; }",
                       Boolean.valueOf(true));
     }
   / opencurly w a1:UseStrictDirectives? w a2:Stmts w closecurly
     { String str = NodeUtil.prBody(toList(a2));
       if (a1 == null)
         yyValue = new Tuple3<List<Stmt>, String, Boolean>(a2, "{ " + str + " }", Boolean.valueOf(false));
       else
         yyValue = new Tuple3<List<Stmt>, String, Boolean>(a2, "{ 'use strict'; " + str + " }", Boolean.valueOf(true));
     };

/*
 * FunctionExpr ::= function (w Id)? w ( (w Params)? w ) w FunctionBody
 */
public LHS FunctionExpr =
     function a1:(w Id)? w openparen a2:(w Params)? w closeparen w a3:FunctionBody
     { Span span = createSpan(yyStart,yyCount+1);
       ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
       Id f = (a1 == null) ? new Id(NodeUtil.makeASTNodeInfo(span), "", Option.<String>apply(null), false) : a1;
       scala.collection.immutable.List<Id> ids;
       if (a2 == null) ids = nilIds;
       else ids = toList(a2);
       yyValue = new FunExpr(info,
                             new Functional(info, nilFds, nilVds,
                                            new Stmts(info, toList(a3._1()), a3._3()),
                                            f, ids, a3._2(), false));
     };



// added

private transient void ARROW = "=>";

public LHS ArrowFunction =
    a2:ArrowParameters w ARROW w a3:ConciseBody
    {      Span span = createSpan(yyStart,yyCount+1);
           ASTNodeInfo info = NodeUtil.makeASTNodeInfo(span);
           Id f = new Id(NodeUtil.makeASTNodeInfo(span), "", Option.<String>apply(null), false);
           scala.collection.immutable.List<Id> ids;
           if (a2 == null) ids = nilIds;
           else ids = toList(a2);
           yyValue = new FunExpr(info,
                                 new Functional(info, nilFds, nilVds,
                                                new Stmts(info, toList(a3._1()), a3._3()),
                                                f, ids, a3._2(),
                                                true));
    };

private Tuple3<List<Stmt>, String, Boolean> ConciseBody =
    FunctionBody
  / &(a1:Assignment) Statement
     {  Span span = createSpan(yyStart,yyCount);
        Stmt returnStmt = new Return(NodeUtil.makeASTNodeInfo(span), Some.<Expr>apply(a1));
        String str = NodeUtil.prBody(toList(list(returnStmt)));
        yyValue = new Tuple3<List<Stmt>, String, Boolean>(list(returnStmt), "{ " + str + " }", Boolean.valueOf(false));
     };


private List<Id> ArrowParameters =
      a1:Id { yyValue = list(a1); }
    / openparen w yyValue:(w Params)? w closeparen;
